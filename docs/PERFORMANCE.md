### 🎓 **一般論: Rust → WASM → ブラウザ実行の性能の現実**

| 段階                                     | 理想                  | 実際の壁・ペナルティ                 |
| -------------------------------------- | ------------------- | -------------------------- |
| Rust ネイティブバイナリ (cargo build --release) | **最高速**             | CPU ネイティブ最適化がフル活用          |
| Rust → WASM (wasm-optあり)               | **2〜20倍速い**ことが期待される | ただしブラウザのWASM実行ランタイムの限界がある  |
| Rust → WASM (wasm-bindgen 経由)          | **期待より遅い場合あり**      | JS/WASM間の呼び出しコスト（FFIコスト）発生 |
| TypeScript / JS                        | 通常                  | JITが効いてそこそこ速い              |

---

### 🚧 **なぜ「思ったより速くならない」のか？（典型パターン）**

#### ① **WASM↔JSの境界コスト（FFIコスト）**

* **wasm-bindgen** や **wasm-pack** 経由でエクスポートすると、

  * `wasm_fn()` 呼ぶたびに **JS → WASM の境界を越えている**
  * これは **意外と高コスト（1回 100ns〜1μs）** が発生する
  * つまり **小さい関数を大量に呼ぶと遅くなる**

##### ➡ **対策**

* **ループは Rust 側に持たせる**
* なるべく「1回の呼び出しで大量に処理」をさせる

---

#### ② **WASM側コードが未最適化**

* デフォルトビルド（wasm-pack build）だと意外と最適化不足
* **wasm-opt -O3** をかけると 2倍〜10倍 速くなるケース多い

##### ➡ **対策**

```sh
wasm-pack build --release
wasm-opt -O3 -o optimized.wasm pkg/your_lib_bg.wasm
```

---

#### ③ **TypeScript 側が意外と速い**

* **V8エンジン（Chrome, Edge, Node）は JIT が非常に高性能**
* 数値計算で「allocが無い」「軽い関数」なら JS がほぼ Rust ネイティブ並になることも

##### ➡ **つまり「WASMが遅い」のではなく「TSが意外と強い」ケースもある**

---

### 🔍 **数値計算系の分類**

| パターン                                 | Rust WASM化での効果                |
| ------------------------------------ | ----------------------------- |
| **重いループ・行列演算・FFT・暗号**                | 💥 **10倍〜100倍** (Rustにする意義大)  |
| **小さな関数の大量呼び出し（例: RNG.next() 1回ずつ）** | ⚠️ **境界コストがボトルネック → 1倍〜3倍程度** |
| **型変換・DOM操作・文字列整形**                  | 🚫 **WASM化しても遅くなることもある**      |

---

### 🏆 **Rust WASMを速くするために必要な最適化**

✅ **① wasm-opt -O3 を必ず使う**
✅ **② FFI (JS↔WASM 境界) の回数を減らす**
✅ **③ Rust 側で「バッチ処理関数」を作る**

* 例: `fn next_n(&mut self, count: usize) -> Vec<f64>`

✅ **④ 不要なアロケーション削除 (alloc-free化)**
✅ **⑤ リンカフラグ最適化 (`-C opt-level=z` や `-C target-feature=+simd128`)**

---

### 🚀 **まとめ**

✅ **Rustネイティブなら 10倍〜100倍速くなることは普通**
✅ **Rust→WASMだと "最適化不足" + "FFIコスト" で "数倍" にしかならない場合が多い**
✅ **適切に最適化すれば WASMでも 10倍程度は狙えるケースは多い**

---

### 🌟 **あなたのケースに当てはめると？**

> GNRNG, createId 系は「**小さな関数をたくさん呼んでいるパターン**」なので **境界コストに引っかかりやすい** です

→ **「next\_n() などのバッチAPI」を Rust 側に作ると劇的に速くなります**
→ そして **wasm-opt -O3** を使えば「期待に近い 10倍〜20倍」出る可能性は高いです

---

### ✅ **次やるべきアクション例**

1️⃣ **wasm-opt 導入**
2️⃣ **バッチAPI設計**

* 例）`create_ids(count: usize) -> Vec<String>`
* 例）`next_n(count: usize) -> Vec<u32>`
  3️⃣ **境界をまたぐ呼び出し回数を極小化**

---
